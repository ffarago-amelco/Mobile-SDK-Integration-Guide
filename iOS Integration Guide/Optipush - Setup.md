# Optipush Setup

## Optipush: Receive and Handle Push Notifications

### 1. Optional: Add `Notification Service Extension` Target
If you already have Notification Service Extension target, please skip this section.

In order to enable Optimove to track the push notifications, you'll need to add a `Notification Service Extension` to your project. This app extension creates a process that handles incoming Push Notifications manipulation. To add this extension to your app please follow the steps below:

1. Select `File > New > Target` on XCode
2. Select the Notification Service Extension target from the `iOS > Application` section
[![Screen-Shot-2019-07-10-at-17-01-44.png](https://i.postimg.cc/05Xh9MH9/Screen-Shot-2019-07-10-at-17-01-44.png)](https://postimg.cc/6TRM03XP)
3. Click `Next`
4. Specify a name for your extension
5. Click `Finish`
6. In your `Podfile` add a new target matching the extension's name

**`Podfile` code snippet**

```ruby
# The Optimove SDK supports iOS version 10 and higher
platform :ios, '10.0'

target 'My Application' do # Your app target
  use_frameworks!
  pod 'OptimoveSDK', '~> 2.0' # We've added this dependency in a previous step
end

target 'NotificationExtension' do # Your new extension target
  use_frameworks!
  # Dependencies will be added here
end
```

### 2. Add the OptimoveNotificationServiceExtension SDK

1. Open your `Podfile`
2. Locate the `Notification Service Extension`'s `target` declaration
3. Add the `OptimoveNotificationServiceExtension` SDK to the target's dependencies list

**`Podfile` code snippet**
```ruby
# The Optimove SDK supports iOS version 10 and higher
platform :ios, '10.0'

target 'My Application' do # Your app target
  use_frameworks!
  pod 'OptimoveSDK', '~> 2.0' # We've added this dependency in a previous step
end

target 'NotificationExtension' do # Your new extension target
  use_frameworks!
  # Dependencies are added here
  pod 'OptimoveNotificationServiceExtension', '~> 2.0'
end
``` 

> **Important Note**: 
> The `Podfile` above will allow any newer minor version of `OptimoveNotificationServiceExtension` not to break the existing API (i.e 2._._) and will be auto-fetched during any `pod update` because the `OptimoveNotificationServiceExtension`  uses __semantic versioning__.


### 3. Setting up Capabilities
Open the **Capabilities** section of your Application's App Target and follow the steps below:

1. Enable the `App Groups` capability and add the following group: `group.<YOUR_APP_TARGET_BUNDLE_ID>.optimove`
![\[Screenshot\]](https://raw.githubusercontent.com/optimove-tech/Optipush-Guide/master/Opitpush%20for%20iOS/Screen%20Shot%202018-07-02%20at%2018.06.21.png)

> ***App Groups*** allow the `Notification Service Extension` and the Application processes to communicate, even though they run in different, isolated environments.

### 4. Forward callbacks to the OptimoveNotificationServiceExtension SDK

1. Open the `NotificationService.swift` file that was generated by XCode for you
2. Locate the following callbacks:
3. The `func didReceive(request:contentHandler:)` callback (Called with the content of the push notification)
4. The `func serviceExtensionTimeWillExpire()` callback (Called when the OS is about to _force kill_ the extension's process)

Example code snippet:

```swift
import UserNotifications
import OptimoveNotificationServiceExtension

class NotificationService: UNNotificationServiceExtension {

  var contentHandler: ((UNNotificationContent) -> Void)?
  var bestAttemptContent: UNMutableNotificationContent?

  var optimoveNotificationServiceExtension:OptimoveNotificationServiceExtension!

  override func didReceive(_ request: UNNotificationRequest, withContentHandler contentHandler: @escaping (UNNotificationContent) -> Void) {
    optimoveNotificationServiceExtension = OptimoveNotificationServiceExtension(appBundleId: "<BUNDLE_ID>")
    if optimoveNotificationServiceExtension.didReceive(request, withContentHandler:  contentHandler) {
      return
    }
    self.contentHandler = contentHandler
    bestAttemptContent = (request.content.mutableCopy() as? UNMutableNotificationContent)

    if let bestAttemptContent = bestAttemptContent {
      // Modify the notification content here...
      bestAttemptContent.title = "\(bestAttemptContent.title) [modified]"

      contentHandler(bestAttemptContent)
    }
  }
    
  override func serviceExtensionTimeWillExpire() {
    if optimoveNotificationServiceExtension.isHandledByOptimove {
      optimoveNotificationServiceExtension.serviceExtensionTimeWillExpire()
    } else {
      if let contentHandler = contentHandler, let bestAttemptContent =  bestAttemptContent {
        contentHandler(bestAttemptContent)
      }
    }
  }
}
```

### 5. UNNotificationCenterDelegate Implementation
Since the `UNUserNotificationCenter` can only have one delegate at a time, the hosting app should conform to the `UNUserNotificationCenterDelegate` protocol and forward two of its callbacks to the Optimove SDK. Please see code snippet below:

```swift
import UIKit
import OptimoveSDK
import UserNotifications

@UIApplicationMain class AppDelegate: UIResponder, UIApplicationDelegate, UNUserNotificationCenterDelegate {

    func application(_ application: UIApplication,
                     didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -> Bool {
        let info = OptimoveTenantInfo(tenantToken: "<YOUR_TENANT_TOKEN>", configName:"<YOUR_CONFIG_NAME>")
        Optimove.configure(for: info)

        UNUserNotificationCenter.current().delegate = self
        return true
    }


    func userNotificationCenter(_ center: UNUserNotificationCenter,
                                didReceive response: UNNotificationResponse,
                                withCompletionHandler completionHandler: @escaping () -> Void) {
        let isHandledByOptimove = Optimove.shared.didReceive(response: response, withCompletionHandler: completionHandler)
        if isHandledByOptimove { return }
        // The notification didn't originate from Optimove's servers, so the app must handle it. Below is the default implementation
        completionHandler()
    }

    func userNotificationCenter(_ center: UNUserNotificationCenter,
                                willPresent notification: UNNotification,
                                withCompletionHandler completionHandler: @escaping (UNNotificationPresentationOptions) -> Void) {
        let isHandledByOptimove = Optimove.shared.willPresent(notification: notification, withCompletionHandler: completionHandler)
        if isHandledByOptimove { return }
        // The notification didn't originate from Optimove's servers, so the app must handle it. Below is the default implementation
        completionHandler([.alert, .badge, .sound])
    }
}
```

## Optipush: Handling Dynamic Deep Links from Optimove
When an Optipush notification is sent with a deep link, it can be passed to the hosting application using the `OptimoveDeepLinkCallback`.

1. The `UIViewController` class that is responsible for deep link routing needs to conform to the `OptimoveDeepLinkCallback` protocol by doing the following:
   1. Implement the `didReceive(deepLink:)` callback
   2. Get the targeted screen from the `OptimoveDeepLinkComponents`'s `screenName` property
   3. Get any custom, personalized parameters from the `OptimoveDeepLinkComponents`'s `params` property
2. Register the `OptimoveDeepLinkCallback` to receive Deep Links from the SDK if available: `Optimove.shared.register(deepLinkResponder: OptimoveDeepLinkResponder(self))`

**Example Code Snippet**

```swift
class ViewController: UIViewController, OptimoveDeepLinkCallback {

    override func viewDidLoad() {
        super.viewDidLoad()
        Optimove.shared.register(deepLinkResponder: OptimoveDeepLinkResponder(self))
    }

    func didReceive(deepLink: OptimoveDeepLinkComponents?) {
        guard let deepLink = deepLink else { 
            // Here you could handle an error
            return 
        }
        
        // Retrieve the targeted screen name
        let screenName = deepLink.screenName
        
        // Retrieve the deep link Key-Value parameters
        let deepLinkParams = deepLink.parameters
    }
}
```
