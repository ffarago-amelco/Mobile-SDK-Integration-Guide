# Optipush Setup

## Receive and Handle Push Notifications

### 1. Add `Notification Service Extension` Target

> Skip this step if you already have a Notification Service Extension target.

In order to enable Optimove to track the push notifications, you'll need to add a `Notification Service Extension` to your project. This app extension creates a process that handles incoming Push Notifications manipulation. To add this extension to your app:

1. Select `File > New > Target` on XCode.
2. Select the Notification Service Extension target from the `iOS > Application` section.
3. Click `Next`.
4. Specify a name for your extension.
5. Click `Finish`.
6. In your `Podfile` add a new target matching the extension's name.

[![Screen-Shot-2019-07-10-at-17-01-44.png](https://i.postimg.cc/05Xh9MH9/Screen-Shot-2019-07-10-at-17-01-44.png)](https://postimg.cc/6TRM03XP)

**`Podfile` code snippet**

```ruby
# The Optimove SDK supports iOS version 10 and higher
platform :ios, '10.0'

target 'My Application' do # Your app target
  use_frameworks!
  pod 'OptimoveSDK', '~> 2.0' # We've added this dependency in a previous step
end

target 'NotificationExtension' do # Your new extension target
  use_frameworks!
  # Dependencies will be added here
end
```

### 2. Add the OptimoveNotificationServiceExtension SDK

1. Open your `Podfile`
2. Locate the `Notification Service Extension`'s `target` declaration
3. Add the `OptimoveNotificationServiceExtension` SDK to the target's dependencies list

**`Podfile` code snippet**
```ruby
# The Optimove SDK supports iOS version 10 and higher
platform :ios, '10.0'

target 'My Application' do # Your app target
  use_frameworks!
  pod 'OptimoveSDK', '~> 2.0' # We've added this dependency in a previous step
end

target 'NotificationExtension' do # Your new extension target
  use_frameworks!
  # Dependencies are added here
  pod 'OptimoveNotificationServiceExtension', '~> 2.0'
end
``` 

> **Important Note**: 
> The `Podfile` above will allow any newer minor version of `OptimoveNotificationServiceExtension` not to break the existing API (i.e 2._._) and will be auto-fetched during any `pod update` because the `OptimoveNotificationServiceExtension`  uses __semantic versioning__.


### 3. Setting up Capabilities

Open the **Capabilities** page for your Application's App Target:

1. Enable the `App Groups` capability. Then add the following group: `group.<YOUR_APP_TARGET_BUNDLE_ID>.optimove`

> ***App Groups*** allow the `Notification Service Extension` and the Application processes to communicate, even though they run in different, isolated environments.

![\[Screenshot\]](https://raw.githubusercontent.com/optimove-tech/Optipush-Guide/master/Opitpush%20for%20iOS/Screen%20Shot%202018-07-02%20at%2018.06.21.png)

### 4. Forward callbacks to the OptimoveNotificationServiceExtension SDK

1. Open the `NotificationService.swift` file that was generated by XCode for you
2. Locate the following callbacks:
3. Locate the `func didReceive(request:contentHandler:)` callback (Called with the content of the push notification)
   1. 
4. Locate the `func serviceExtensionTimeWillExpire()` callback (Called when the OS is about to _force kill_ the extension's process)
   1. 

### 5. UNNotificationCenterDelegate Implementation

Because the `UNUserNotificationCenter` can have only 1 delegate, the hosting app should conform to the `UNUserNotificationCenterDelegate` protocol and forward 2 of its callbacks to the Optimove SDK:

```swift
import UIKit
import OptimoveSDK
import UserNotifications

@UIApplicationMain class AppDelegate: UIResponder, UIApplicationDelegate, UNUserNotificationCenterDelegate {

    func application(_ application: UIApplication,
                     didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -> Bool {
        let info = OptimoveTenantInfo(tenantToken: "<YOUR_TENANT_TOKEN>",configName:"<YOUR_CONFIG_NAME>")
        Optimove.configure(for: info)

        UNUserNotificationCenter.current().delegate = self
        return true
    }


    func userNotificationCenter(_ center: UNUserNotificationCenter,
                                didReceive response: UNNotificationResponse,
                                withCompletionHandler completionHandler: @escaping () -> Void) {
        let isHandledByOptimove = Optimove.shared.didReceive(response: response, withCompletionHandler: completionHandler)
        if isHandledByOptimove { return }
        // The notification didn't originate from Optimove's servers, so the app must handle it. Below is the default implementation
        completionHandler()
    }

    func userNotificationCenter(_ center: UNUserNotificationCenter,
                                willPresent notification: UNNotification,
                                withCompletionHandler completionHandler: @escaping (UNNotificationPresentationOptions) -> Void) {
        let isHandledByOptimove = Optimove.shared.willPresent(notification: notification, withCompletionHandler: completionHandler)
        if isHandledByOptimove { return }
        // The notification didn't originate from Optimove's servers, so the app must handle it. Below is the default implementation
        completionHandler([.alert, .badge, .sound])
    }
}
```

## Optipush: Handling Dynamic Deep Links from Optimove

When an Optipush notification is sent with a deep link, it can be passed to the hosting application using the `OptimoveDeepLinkCallback`.
1. The `UIViewController` class that is responsible for deep link routing needs to conform to the `OptimoveDeepLinkCallback` protocol.
   1. Implement the `didReceive(deepLink:)` callback
   2. Get the targeted screen from the `OptimoveDeepLinkComponents`'s `screenName` property
   3. Get any custom, personalized parameters from the `OptimoveDeepLinkComponents`'s `params` property
2. Register the `OptimoveDeepLinkCallback` to receive Deep Links from the SDK if available: `Optimove.shared.register(deepLinkResponder: OptimoveDeepLinkResponder(self))`

**Example Code Snippet**

```swift
class ViewController: UIViewController, OptimoveDeepLinkCallback {

    override func viewDidLoad() {
        super.viewDidLoad()
        Optimove.shared.register(deepLinkResponder: OptimoveDeepLinkResponder(self))
    }

    func didReceive(deepLink: OptimoveDeepLinkComponents?) {
        let deepLinkVC = storyboard?.instantiateViewController(withIdentifier: "deepLinkVc")
        guard let deepLink = deepLink,
            let deepLinkVC as? DeepLinkViewController else { 
            // Here you could handle an error
            return 
        }
        
        // Retrieve the targeted screen name
        let screenName = deepLink.screenName
        
        // Retrieve the deep link Key-Value parameters
        let deepLinkParams = deepLink.parameters
    }
}
```
